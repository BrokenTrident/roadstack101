# ============================================================================
# DOCKER COMPOSE CONFIGURATION
# ============================================================================
# Docker Compose lets us define and run multi-container applications
# Instead of running multiple "docker run" commands, we define everything here
#
# Key Concepts for Learners:
# - Services: Each container (frontend, backend, database, etc.)
# - Volumes: How we share code between host machine and containers
# - Networks: Containers can talk to each other by service name
# - Ports: How we access containers from our host machine (localhost)
# ============================================================================

# ============================================================================
# FILE NAMING NOTE
# ============================================================================
# Docker's official convention is now "compose.yaml" (without "docker-" prefix).
# We use "docker-compose.yml" for clarity in this tutorial, but both work.
# See: https://docs.docker.com/compose/compose-file/
# ============================================================================

# ============================================================================
# DEVELOPMENT APPROACH: VOLUME MOUNTS
# ============================================================================
# This file uses VOLUME MOUNTS for development hot-reload. Your host files
# are shared directly with the container - changes appear instantly.
#
# For the alternative COMPOSE WATCH approach, see: docker-compose.watch.yml
#
# Quick comparison:
# - Volume Mounts (this file): Simple, shares entire directories
# - Compose Watch (other file): Explicit control over sync/rebuild rules
# ============================================================================

services:

  # ==========================================================================
  # FRONTEND SERVICE - Next.js Application
  # ==========================================================================
  frontend:
    # ----------------------------------------------------------------------
    # PLATFORM (for Apple Silicon Macs)
    # ----------------------------------------------------------------------
    # Uncomment the line below if you're on Apple Silicon (M1/M2/M3 Mac)
    # and experiencing slow performance without Docker Desktop virtualization
    # PER.NOTE (DC): This is specific to our company, but can be ignored if you're
    # not on an ARM system
    # platform: linux/arm64/v8

    # ----------------------------------------------------------------------
    # BUILD CONFIGURATION
    # ----------------------------------------------------------------------
    build:
      # Context: The base directory for building (paths are relative to this)
      context: .
      # Dockerfile: Specific Dockerfile to use for this service
      dockerfile: ./docker/frontend.Dockerfile

    # ----------------------------------------------------------------------
    # CONTAINER NAME
    # ----------------------------------------------------------------------
    # Friendly name for this container (easier than random names Docker generates)
    # You'll see this name when you run: docker ps
    container_name: roadstack-frontend

    # ----------------------------------------------------------------------
    # PORT MAPPING
    # ----------------------------------------------------------------------
    # Format: "HOST_PORT:CONTAINER_PORT"
    # - 3000 (left): Port on YOUR computer (localhost:3000)
    # - 3000 (right): Port inside the container (where Next.js listens)
    # Change the left number if you want to use a different port on your machine
    ports:
      - "3000:3000"

    # ----------------------------------------------------------------------
    # VOLUMES (FILE SHARING)
    # ----------------------------------------------------------------------
    # Volumes let you share files between your computer and the container
    # This is CRUCIAL for development: changes you make appear instantly!
    #
    # Format: "HOST_PATH:CONTAINER_PATH"
    volumes:
      # Share the frontend code directory
      # Changes you make to files will immediately be visible in the container
      - ./frontend:/app

      # Node modules volume - **IMPORTANT**
      # This creates an "anonymous volume" for node_modules
      # Why? node_modules can be platform-specific (Mac vs Linux)
      # This ensures the container uses the Linux-built modules
      # while letting you edit code freely
      - /app/node_modules

      # Alternative approach (named volume - more explicit):
      # - frontend_node_modules:/app/node_modules

    # ----------------------------------------------------------------------
    # RESTART POLICY
    # ----------------------------------------------------------------------
    # "unless-stopped" means:
    # - If container crashes, Docker will restart it automatically
    # - If you manually stop it, it stays stopped
    # - When you restart Docker, it starts this container
    # Alternatives: "no", "always", "on-failure"
    restart: unless-stopped

    # ----------------------------------------------------------------------
    # ENVIRONMENT VARIABLES (Optional)
    # ----------------------------------------------------------------------
    # You can set environment variables for the container
    # Useful for API URLs, feature flags, etc.
    # environment:
    #   - NODE_ENV=development
    #   - NEXT_PUBLIC_API_URL=http://backend:8000
    #
    # Instead of the above env 'variables', you can instead
    # share env 'files' which the following does, choose ONLY ONE of these
    # env_file:
    #   - <ENV_FILE_PATH>

    # ----------------------------------------------------------------------
    # NETWORKS (Optional but useful to understand)
    # ----------------------------------------------------------------------
    # By default, all services are on the same network
    # Services can reach each other using the service name as hostname
    # Example: frontend can call "http://backend:8000" (not localhost:8000!)

  # ==========================================================================
  # BACKEND SERVICE - Django REST API
  # ==========================================================================
  backend:
    # ----------------------------------------------------------------------
    # PLATFORM (for Apple Silicon Macs)
    # ----------------------------------------------------------------------
    # Uncomment if needed (same as frontend explanation)
    # platform: linux/arm64/v8

    # ----------------------------------------------------------------------
    # BUILD CONFIGURATION
    # ----------------------------------------------------------------------
    build:
      context: .
      dockerfile: ./docker/backend.Dockerfile

    # ----------------------------------------------------------------------
    # CONTAINER NAME
    # ----------------------------------------------------------------------
    container_name: roadstack-backend

    # ----------------------------------------------------------------------
    # PORT MAPPING
    # ----------------------------------------------------------------------
    # Django development server runs on port 8000
    # Access at: http://localhost:8000
    ports:
      - "8000:8000"

    # ----------------------------------------------------------------------
    # VOLUMES (FILE SHARING)
    # ----------------------------------------------------------------------
    volumes:
      # Share the backend code directory
      # Changes to Python files will be detected by Django's auto-reloader
      - ./backend:/app

      # SQLite database persistence (named volume)
      # This ensures your database survives container restarts and rebuilds
      # Without this, all data would be lost when you run "docker compose down"
      # The database file will be stored at /app/core/db/db.sqlite3 in the container
      - sqlite_data:/app/core/db

      # Alternative for PostgreSQL (if you switch to PostgreSQL later):
      # - postgres_data:/var/lib/postgresql/data

    # ----------------------------------------------------------------------
    # RESTART POLICY
    # ----------------------------------------------------------------------
    restart: unless-stopped

    # ----------------------------------------------------------------------
    # ENVIRONMENT VARIABLES (Optional but common)
    # ----------------------------------------------------------------------
    # environment:
    #   # Tell Django we're in development mode
    #   - DEBUG=True
    #   # Database connection string (if using PostgreSQL)
    #   - DATABASE_URL=postgresql://user:password@db:5432/mydb
    #   # Django secret key (use environment variable in production!)
    #   - SECRET_KEY=your-secret-key-here

    # ----------------------------------------------------------------------
    # DEPENDS ON (Optional)
    # ----------------------------------------------------------------------
    # If you add a database service, you'd specify it here
    # This ensures the database starts before the backend
    # depends_on:
    #   - db

# ============================================================================
# VOLUMES (Named Volumes Definition)
# ============================================================================
# Named volumes must be declared here at the root level
# These volumes persist data across container restarts and rebuilds
# Location: Managed by Docker (usually in /var/lib/docker/volumes/)
#
# To inspect a volume: docker volume inspect roadstack101_sqlite_data
# To backup: docker compose exec backend cp /app/core/db/db.sqlite3 /app/backup.sqlite3
# To delete: docker compose down -v (WARNING: This deletes ALL data!)
volumes:
  # SQLite database storage
  # This volume stores the SQLite database file, ensuring data persistence
  # Without this, database would be recreated (empty) every time you rebuild
  sqlite_data:

  # Example: If you were using PostgreSQL instead
  # postgres_data:

  # Example: If you want to persist uploaded files/media
  # media_files:

# ============================================================================
# NETWORKS (Custom Networks)
# ============================================================================
# You can define custom networks if needed
# By default, Compose creates a network for all services
# networks:
#   app_network:

# ============================================================================
# USEFUL COMMANDS FOR LEARNERS
# ============================================================================
#
# STARTING SERVICES (this file - volume mounts):
#   docker compose up --build           # Build and start all services
#   docker compose up -d                # Start in background (detached)
#   docker compose --dry-run up         # Preview what would happen (no changes)
#
# USING COMPOSE WATCH (alternative file):
#   docker compose -f docker-compose.watch.yml watch
#   docker compose -f docker-compose.watch.yml --dry-run watch
#
# STOPPING SERVICES:
#   docker compose down                 # Stop and remove containers
#   docker compose down -v              # Also remove volumes (deletes data!)
#
# VIEWING LOGS:
#   docker compose logs                 # All services
#   docker compose logs frontend        # Specific service
#   docker compose logs backend -f      # Follow mode (live)
#
# RUNNING COMMANDS IN CONTAINERS:
#   docker compose exec frontend npm install
#   docker compose exec backend python manage.py migrate
#   docker compose exec backend python manage.py createsuperuser
#
# REBUILDING:
#   docker compose up --build           # Rebuild all services
#   docker compose up --build frontend  # Rebuild specific service
#
# ============================================================================
